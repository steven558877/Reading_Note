# 防禦性程式設計
子程式不應因傳入非法參數而被破壞，在開發時也不要引入錯誤，例如開始之前先寫虛擬碼、TDD等等技術避免引入錯誤
## 保護程式免遭非法輸入資料破壞
1. 檢查所有外來的資料
2. 檢查其他子程式輸入的資料
3. 決定如何處裡錯誤的輸入資料

## 斷言(assertion)
做程式自我測試時用，例如某個函數帶入某參數應該要回傳某個值，否則就是錯誤，就要用斷言，斷言程式有錯。通常只有在開發中會將斷言的程式碼寫入產品程式碼中，發布後就會清除。

### 使用斷言的指引
1. 錯誤處理程式是用來接可能會發生的錯誤，而斷言是用來處理絕不該發生的事。錯誤處理通常是來防止有害的輸入，而斷言是用來檢查程式的BUG。
2. 避免把需要執行的程式放入斷言中，因為如果後來關閉斷言功能後可能會被編譯器最佳化掉，因此最好將程式拉出來執行再將結果丟給斷言判斷。
3. 用斷言來註解並驗證前置條件及後置條件。例如以下函式:
	```C++
	int fun(int K)
	```
	他的前置條件為K，就是說K要合法，可能是 0 < K < 100。而後置條件則
		為fun 回傳的值有沒有達到條件。
4. 對於高健全的程式碼，應該先使用斷言在使用錯誤處理，通常這兩個不會同時使用，但是在大型程式碼中可以使用(這段看不太懂，參考書中P.195)

## 錯誤處理技術
當我們預期會遇到錯誤時能夠適當的選擇下列手段單獨或合併使用:
* 返回中立值
	* 選擇一個適當的中立值返回，例如0或是空字串等等，但如果是在一些要求準確度的場合時，停止程式會比返回中立值適當。
*  換用下一筆正確資料
	* 有時候資料流出現錯誤時只需要讀取下一筆正確資料即可，例如以每秒一千次的頻率量測體溫，如果這次量測有問題，只需要等1/1000秒的時間即可得到下一筆正確資料。
* 返回與前次相同的值
	* 如同上面體溫的舉例，你也可以返回上次量到的正確體溫。但如果是用於銀行的交易就不能使用這個方法，因為上次成功交易可能是別人的值。
* 換用最接近的合法值
	* 例如溫度合法範圍為0~100時，量到小於0或是大於100的就可以換成最接近的合法值。
* 將警告訊息寫入日誌
	* 可以和其他方法合併使用
* 返回錯誤碼
	* 只簡單回報有錯誤發生，後續處理交給其他子程式。
	* 可以設定並回傳狀態值
	* 也可以使用語言內建的例外處理
* 呼叫錯誤處理子程式
	* 優點在於能將所有錯誤集中處理，缺點在於攻擊者可能可以修改此程式，再引發錯誤，導致程式不再安全
* 顯示錯誤訊息
	* 但要調整適當的資訊量
* 用最妥當的方式局部處理錯誤
	* 彈性很高，但是會影響系統整體的正確性或健全性(下述)
* 關閉程式
	* 攸關人生安全的程式或是資訊安全的環境，用這方法是ok的
### 健全性(robustness)與正確性(correctness)
健全性是指寧願回傳回一個不那麼正確的資料也要回傳，正確性是指寧願停止程式也不要回傳不正確的資料

### 高層程式設計對錯誤處理方式的影響
有這麼多錯誤處理方式的選擇，整個程式內應要採取一致的方式處理。一但採用了某方法就要貫徹執行。例如你決定再高層處理錯誤，低層只回報錯誤那就要嚴格執行，確保高層真的有處理錯誤。記得再你覺得不會覺不會發生錯誤的地方加入錯誤偵測，這是防禦性程式設計的核心概念- 防禦
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0NzU4MDg1MDYsLTEyNzIyODM4MzEsLT
kwMjY1NzEyMSwxNDAyMzQxMzEzLC0xNDQwMjEwOTMwLC01OTM0
NjY0NywxMTgyNzAxMTM5LDEwMjIyMzY2NTAsMjA2NTQ1MTA4XX
0=
-->