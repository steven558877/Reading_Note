# 基礎資料型別
* 預防 devide by zero 的錯誤
	* 如果有用到除法，要注意這個問題
* 使型別轉換變得明顯
	* `y = x + (float)z`
## 整數
* 檢查整數溢出
	* 注意整數的範圍，處裡時要注意是否會溢出
## 浮點數
* 避免差距過大的計算
	* 例如 100,000,000.0 + 0.001，這樣可能會使變數的 bit 數不足以表達這個數字。
	* 如果必要，則需要對輸入做排序，從最小的數值開始加，加到最大值
* 要比較兩個浮點數，不能直接用 = 判斷，很可能會因為精準度而導致與預想不同
	* 可以的做法是實現一個 Equal 函數，裏頭會包含誤差值，使得兩個浮點數在一定的誤差值內可以被視為相同
* 處裡捨入誤差
	* 用更高精準度的型別
	* 使用 binary coded decimal (?)
	* 把浮點數變成整數，例如一個浮點數是 1.23，你可以把整數部分及小數部分皆乘上 100，變成 123 ，這樣就解決精準度的問題

## 布林
* 布林變數對程式加以說明，盡量將判斷表現出意義，如下用一個 finished 變數將判斷接起來，達到更有意義的說明
```C++
bool finished = (index<0 || MAX_ELEMENT < index);
if (finished)
{
...
}
```
## 列舉
* 用列舉型別來簡化修改
	* 未來要修改，只需修改列舉型別即可
* 將列舉型別作為布林的延伸
	* 可以有多種 false 的原因
* enum可以設定開頭及結尾的無用列舉，可以利於迴圈的使用
* enum 第一個元素設定為非法值
* 明確定義專案中的列舉第一個及最後一個的使用規則，並且保持一致
* 警惕列舉元素明確賦值所導致的錯誤
	* 像是用 for 迴圈去遍歷所有列舉的元素時，有可能會遍歷到某個不包含的元素
		* 例如下面的例子就會遍歷到不存在的元素 1 :
		```c
		enum Color {
			Color_Black = 0
			Color_Yellow = 2
		}
		```
## 陣列
* 確保所有陣列存取都沒有超過邊界值
* 陣列的使用會比較建議改用容器，或是其他順序化的結構來處理，出錯率會較低
	* 像是相比於使用陣列，使用 set, stack, queue 等會比較安全
* 檢查陣列的邊界點
	* 避免 off-by-one 的問題
## 建立自己的型別
* 易於修改
* 避免過多的資訊分發
	* 用 hard-coded 的方式會導致同個程式碼散落在各地
* 增加可靠性
	* Ada 可以在定義時設定數值範圍，但是C++沒有這功能
### 建立自訂義資料型別的指導原則
* 給所建立的型別取功能導向的名稱
	* 避免使用型別底層所使用的型別的名稱
	* 應該用能表現現實問題的名稱
	* 用自訂義的型別就是要將底層的型別與實際問題切割，不
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExMDY2NDg2MTIsNTk2OTM2MzIsNTQwNz
A3NTg4LDk1MTcxNTgzNyw1OTgxNjU3NjEsNzM5MDk1MTUzLDkx
MjI4MzU0MywyMDgwMjAzNjM4LC0xMTY0ODYwNTM0LC0xMjAwOD
U2NjU1XX0=
-->