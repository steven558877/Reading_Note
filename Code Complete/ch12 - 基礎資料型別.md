# 基礎資料型別
* 預防 devide by zero 的錯誤
	* 如果有用到除法，要注意這個問題
* 使型別轉換變得明顯
	* `y = x + (float)z`
## 整數
* 檢查整數溢出
	* 注意整數的範圍，處裡時要注意是否會溢出
## 浮點數
* 避免差距過大的計算
	* 例如 100,000,000.0 + 0.001，這樣可能會使變數的 bit 數不足以表達這個數字。
	* 如果必要，則需要對輸入做排序，從最小的數值開始加，加到最大值
* 要比較兩個浮點數，不能直接用 = 判斷，很可能會因為精準度而導致與預想不同
	* 可以的做法是實現一個 Equal 函數，裏頭會包含誤差值，使得兩個浮點數在一定的誤差值內可以被視為相同
* 處裡捨入誤差
	* 用更高精準度的型別
	* 使用 binary coded decimal (?)
	* 把浮點數變成整數，例如一個浮點數是 1.23，你可以把整數部分及小數部分皆乘上 100，變成 123 ，這樣就解決精準度的問題

## 布林
* 布林變數對程式加以說明，盡量將判斷表現出意義，如下用一個 finished 變數將判斷接起來，達到更有意義的說明
```C++
bool finished = (index<0 || MAX_ELEMENT < index);
if (finished)
{
...
}
```
## 列舉
* 用列舉型別來簡化修改
	* 未來要修改，只需修改列舉型別即可
* 將列舉型別作為布林的延伸
	* 可以有多種 false 的原因
* enum可以設定開頭及結尾的無用列舉，可以利於迴圈的使用
* enum 第一個元素設定為非法值
* 明確ㄉㄧ
* 陣列的使用會比較建議改用容器，出錯率會較低
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0NDAyNzgyNDMsNTQwNzA3NTg4LDk1MT
cxNTgzNyw1OTgxNjU3NjEsNzM5MDk1MTUzLDkxMjI4MzU0Mywy
MDgwMjAzNjM4LC0xMTY0ODYwNTM0LC0xMjAwODU2NjU1XX0=
-->