# 工作類別
類別是由一組資料和子程式構建出來的集合， 這些資料和子程式共同擁有一組內聚的、明確定義的職責。 成為一個有效率的工程師的關鍵在於 當你開發程式中了一部分的程式碼時， 都盡可能的忽視程式的其餘部分而不會有所擔心， 類別就是達成這個任務的工具。
## 類別的基礎： 抽象資料類型（adt）
### 使用adt的好處
如果沒有adt， 程式將會使用拼湊的方式實現。 但不是說 拼湊法 不好， 而是我們可以採取一個更好的程式設計方式來替代這種方法。
#### 可以隱藏實作細節
#### 更動不會影響到整個程式
#### 讓介面能夠提供更多資訊
當在寫程式時， 你指定一個字體大小的變數值為16， 你並不知道他的單位是什麼， 將這類的訊息分別根據單位在類別內定義就可解決這個問題
#### 更容易提高效能
#### 用程式的正確性顯而易見
當要設定字體屬性時，使用font.attribute=0x20是有可能會出錯的，可能會物打成0x02。如果有一類別函是為font.setBold()，則可以清楚的知道屬性的設定正確性。
#### 程式更具自我說明性
如上例 就知道這個函式是用來將字體 設定為粗體。
#### 無需在程式內到處傳的資料
####  你可以像在現實世界中哪樣操作實體 而不用在底層實作上操作他
指的是 定義 一堆 函式去實現原本需要用 拼湊法 達成的功能。
### 更多adt的範例
#### 把常見的底層資料類型建立為adt， 並使用它們 ，而不再使用底層資料類型
使用adt時 會使用一些常見的底層資料結構 但是 當我們要看 在adt中 這些資料結構 代表的意義意思時， 應該 要抽高抽象層次去看 像是1組 佇列 代表1組演員， 若我們應該把該資料結構 它看成一組演員而非一組祝列
#### 把像檔案這樣常用的物件當成ADT
作業系統的檔案系統就像是一個adt 你對檔案進行操作 會使用複製貼上的功能 而這就是ADt 因為檔案 檔案在硬碟內要用磁盤跟指針去尋找 而你不會操作到這些控制 這就是一個adt的例子
#### 簡單的事物也可以當作ADT
 像開關燈的操作 雖然簡單但也可以使用ADT 因為這會讓程式碼 提高 自我說明能力 並且讓程式碼更容易修改
 #### 不要讓adt依賴於他的儲存介質
 如果你把一個 ADT取名為RateFile並使用讀取read()的函式時會將檔案從硬碟中讀出，但是如果ADT的讀取 功能改成由記憶體讀取 則ratefile就不正確，因此在為類別取名時要避免他與儲存方式相關。
 ### 在非物件導向環境中用ADT處理多份資料的實例 
 如果 使用 非物件導向的語言並想應用adt的概念，參考書中p133
 ## 良好的類別 介面
 要建立 高品質的類別 最重要的一 步跟第一 步就是建立良好的介面 包含透過介面來展現良好的抽象並且確保細節被 隱藏
 ### 良好的抽象
 一個良好的抽象應該是在類別內有相關性 有高度的內聚力， 下面是一些可用於建立類別介面實的 指引
 #### 類別介面應該展現已製的抽象 層次
 在類別思考時 有一個很好的方法 就是寶把類別看作一種用來實作adt的機制 每一個類別應該是實作一個adt並且只實作這個adt。 如果發現某個類別不只是做一個adt， 則需要重新組織成一個或多個更明確的ADT，可看書中p137的例子
 #### 一定要理解類別所實作的抽像是什麼
 書中舉例作者開發一個 方格 控制項的界面 但是實際上 他是試算表控制項 因此使用 方格控制項的界面包裹試算表控制項， 而因為作者是想開發方格控制項 因此 暴露出來的 子程式只有跟方個控制項有關， 試算表控制項的子程式都被隱藏起來。
 #### 提供成對的服務
 大多數操作都有何其相應及相等或是相反的操作， 因此在建立類別的公用 子程式時， 要決定是否需要另外一個與之 相補的操作
 #### 把不相關的資訊移到其他類別中
 #### 盡可能讓介面可程式化， 而不是表達語義
  可程式化 指的是 界面中的資料類型和其他屬性 構成， 可被編譯器 檢查 錯誤， 而表達語意 指的 這個界面應該要怎麼被使用。 因為 表達語意的功能無法被編譯器檢查錯誤， 因此表達 語意 應該 用註解的方式， 讓介面不依賴這些說明
  #### 謹防在修改時破壞介面的抽象
  #### 不要添加於介面抽象不一致的公用成員
  #### 同時考慮抽象性和內聚性
  通常有良好的抽象性時該類別都有良好的 內聚性， 因此當你發現某個類別的內聚性很弱 但又不知道怎麼改時， 可以改問自己這個類別是否表現一致的頭像。
  ### 良好的封裝
  封裝相比於抽象， 封裝是強制阻止你看到細節怎麼實作， 而抽象只是可以讓你 忽略實作。 作者的經驗來說只要沒有封裝抽象往往很容易被打破， 因此這兩個通常會一起都有
  #### 盡可能的限制類別和成員的 可存取性
  有一個 判斷標準是 採用哪種方式最能保護介面抽象的完整性， 以此去判斷要使用public, protect還是private。
  #### 不要公開暴露成員資料
  #### 避免把私用的實作細節放入類別的介面中
   例如在類別的private屬性中直接使用string新增一個成員，這樣就暴露了成員的實作，書中提到effective c++的做法是新增一個此類別的實作類別，只有此類別能使用該實作類別並使用實作類別取得實作此類別的成員。
   #### 不要對類別的使用者做出任何假設
   類別的設計和實作應該符合類別介面 所隱藏的用意， 不應該假設他會被如何使用或是不會被如何使用， 像是下面的例子
   ```
   -- 請將x, y, z 初始化為1,否則會崩潰。
   ```
   #### 避免使用friend class
   在某些特定環境下 使用 friend class 可以幫助管理複雜度， 但在一般情況下 friend class 會破壞封裝。
   #### 不要因為一個子程式裡僅 使用 公用 子程式 就把他歸入公開介面
   一個子程式只使用公開的子程式就把他公開不是一個重要的考慮因素， 而是該考慮提供介面時有沒有需要公開這個程式
   #### 讓閱讀程式碼比編寫程式碼更方便
   在開發時通常閱讀程式碼的時間會比編寫程式碼時間還要長， 因此可讀性非常重要， 在一個類別中當有一子程式並非完全符合這個類別， 但是可能會讓開發更方便， 我們必須避免這個狀況以免影響可閱讀性。
   #### 要格外警惕從語意上破壞封裝性
   破壞封裝性可以從語義上或者是從語法上， 語法上可以輕易地透過private解決， 而語法上就是完全另外一件事，例如下面有問題的例子:
   * 不去呼叫A類別的Init()，因為你知道在PerformFirstOeration()時就會呼叫過
   * 不在Retrieve(database)前呼叫database.Connect()，因為你知道在裡頭她會去判斷有沒有跟database連線上。
   * 不去呼叫A類別的Terminate()，因為你知道在PerformFinalOeration()時就會呼叫
   上面的問題在於你 呼叫程式碼時 不是依賴於類別的公開介面， 而是依賴於類別的私用實作， 每當你發現自己是透過查看類別內部的 實作 來得知如何使用這個類別時， 你就已經不是在針對介面寫程式了， 而是由經過界面直接針對內部的實作來寫程式， 破壞了封裝性， 一旦破壞了 封裝性 ，抽象能力也就遭殃了
   而當如果你不知道如何使用一個類別的公開介面時， 不是拉出類別的原始碼， 去看裡面的實作， 而是去聯絡作者， 告知他他不知道怎麼使用這個類別， 而你想得到的也不是他真的 怎麼做， 而是由他去修改類別介面， 修改完後再讓你看看你能不能知道如何使用。
   #### 留意過於緊密的耦合關係
   通常兩個類別越是losse coupling越好，以下是建議
   * 盡可能限制著類別和成員的可存取性
   * 避免使用友誼類別， 因為他們是緊密耦合的
   * 在基底類別中把資料宣告為private而非protected， 以正的衍生類別和基底類別之間的耦合程度
   * 避免在類別的公開 界面中 暴露成員資料
   * 對於從語義上破壞封裝性保持警惕
   * 察覺6-3節講的Demeter法則
   ##  有關設計和實作的議題
   ### 包含（has a ......的關係）
   包含（containment） 表示的是一個類別含有1個基本資料元素和物件
   ####  經由包含來實作has a關系
   例如員工有一個（has a）姓名、 一個電話號碼， 那你可以讓姓名、電話號碼 成為員工 類別的資料成員
   #### 在萬不得已時經由private繼承來實作has a關係
   在某些狀況你發現無法把一個物件當作另外一個物件的成員來實作包含關係， 一些專家建議可以使用private繼承來實作has a， 這麼做的原因是要讓包含那邊能夠存取被包含類別的protected成員， 但這個做法會造成衍生類別與基底類別形成一種過於緊密的關係而破壞封裝性。
   #### 警惕有超過約7個資料成員的類別
   
   ### 繼承是一個s a關係
   繼承的概念是說某一個類別是另外一個類別的特殊化。 其目的在於透過一個基底類別來定義出兩個或多個衍生類別 並提供共有元素
   從決定使用騎乘時你必須要做一下決策
   * 對於每一個成員函數而言他應該對衍生類別可見嗎？ 他應該有預設的實作嗎？ 這個預設的實作能被複寫嗎？
   * 每一個資料成員而言他應該對衍生類別可見嗎
   下面來詳細解釋如何考慮這些事項
   #### 用public 繼承來實作一個s a關係
   使用 繼承 來建立新類別時， 是在表明這個新類別是現有類別的特殊版本， 基底類別會對衍生類別作什麼有所期待， 也做出了限制， 因此如果衍生類別無法完全遵守基底類別定義的介面契約時， 繼承就不是一個正確的實作技術 ，請改用包含的方式
   #### 要使用繼承就要進行詳細說明， 否則不要使用，因為繼承是一個危險、增加複雜度的技術
#### 遵循LISKOV替代原則
liskov總結為 衍生類別必須能透過基底類別的介面而被使用， 且使用者無需了解兩者之間的差異， 否則會因為不同的衍生類別需要去記憶相同名稱的函式卻做不同事情。
#### 確保只繼承需要繼承的部分
衍生類別可以只繼承函式成員的介面和實作也可以介面與實作都繼承。 當你選擇透過繼承的方式實作一個新類別時，請針對每一個子程式仔細考慮你所希望繼承的方式。 如果你只想使用一個類別的實作而不是介面， 那就應該採用包含的方式而不該用繼承。
#### 不要覆寫一個不可覆寫的 成員函式
例如 一個函式在基底類別是private， 折騎乘後不該取一個相同名稱的函式，因為閱讀者會以為你是在覆寫他，但其實只是剛好同名而已。
#### 把共用的介面、資料及操作放在繼承樹中盡可能高的位置
如果你發現一個子程式移到更高的後會破壞該層物件的抽象性
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYwMzA4ODQ2MCw1NDI3NTg0NDgsMjAwMT
I2NTI0MiwxNjQwMTA4OTM1LDIxMTE5NjIwMDIsLTE4MDIwNDU3
NywtOTk3OTUxOTE5LDgwMDQ5MzgxOCwtMTk4MDc3OTgxMiwtNj
YzNzUyNzMwLDc3MTE0OTIxOSwxMTIzOTYyNDkxLDIwOTgwNjYw
MiwxNDcyNDk3OTQzLDEwNjQxMjE3MDMsMzQ5ODY2NzksNjE5NT
k3OTQyLDIzNTY1Nzk5MCwxNjAxNDIyNzQ0LDE1NDg2Njg3NDdd
fQ==
-->