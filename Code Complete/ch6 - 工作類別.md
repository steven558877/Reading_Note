# 工作類別
類別是由一組資料和子程式構建出來的集合， 這些資料和子程式共同擁有一組內聚的、明確定義的職責。 成為一個有效率的工程師的關鍵在於 當你開發程式中了一部分的程式碼時， 都盡可能的忽視程式的其餘部分而不會有所擔心， 類別就是達成這個任務的工具。
## 類別的基礎： 抽象資料類型（adt）
### 使用adt的好處
如果沒有adt， 程式將會使用拼湊的方式實現。 但不是說 拼湊法 不好， 而是我們可以採取一個更好的程式設計方式來替代這種方法。
#### 可以隱藏實作細節
#### 更動不會影響到整個程式
#### 讓介面能夠提供更多資訊
當在寫程式時， 你指定一個字體大小的變數值為16， 你並不知道他的單位是什麼， 將這類的訊息分別根據單位在類別內定義就可解決這個問題
#### 更容易提高效能
#### 讓程式的正確性顯而易見
當要設定字體屬性時，使用font.attribute=0x20是有可能會出錯的，可能會物打成0x02。如果有一類別函是為font.setBold()，則可以清楚的知道屬性的設定正確性。
#### 程式更具自我說明性
如上例 就知道這個函式是用來將字體 設定為粗體。
#### 無需在程式內到處傳的資料
####  你可以像在現實世界中哪樣操作實體 而不用在底層實作上操作他
指的是 定義 一堆 函式去實現原本需要用 拼湊法 達成的功能。
### 更多adt的範例
#### 把常見的底層資料類型建立為adt， 並使用它們 ，而不再使用底層資料類型
使用adt時 會使用一些常見的底層資料結構 但是 當我們要看 在adt中 這些資料結構 代表的意義意思時， 應該 要抽高抽象層次去看 像是1組 佇列 代表1組演員， 若我們應該把該資料結構 它看成一組演員而非一組祝列
#### 把像檔案這樣常用的物件當成ADT
作業系統的檔案系統就像是一個adt 你對檔案進行操作 會使用複製貼上的功能 而這就是ADt 因為檔案 檔案在硬碟內要用磁盤跟指針去尋找 而你不會操作到這些控制 這就是一個adt的例子
#### 簡單的事物也可以當作ADT
 像開關燈的操作 雖然簡單但也可以使用ADT 因為這會讓程式碼 提高 自我說明能力 並且讓程式碼更容易修改
 #### 不要讓adt依賴於他的儲存介質
 如果你把一個 ADT取名為RateFile並使用讀取read()的函式時會將檔案從硬碟中讀出，但是如果ADT的讀取 功能改成由記憶體讀取 則ratefile就不正確，因此在為類別取名時要避免他與儲存方式相關，這邊取作 rate.Read() 這樣會比較正確。
 ### 在非物件導向環境中用ADT處理多份資料的實例 
 如果 使用 非物件導向的語言並想應用adt的概念，參考書中p133
 ## 良好的類別 介面
 要建立 高品質的類別 最重要的一 步跟第一 步就是建立良好的介面 包含透過介面來展現良好的抽象並且確保細節被 隱藏
 ### 良好的抽象
 一個良好的抽象應該是在類別內有相關性 有高度的內聚力， 下面是一些可用於建立類別介面實的 指引
 #### 類別介面應該展現一致的抽象 層次
 在類別思考時 有一個很好的方法 就是把類別看作一種用來實作adt的機制 每一個類別應該是實作一個adt並且只實作這個adt。 如果發現某個類別不只是做一個adt， 則需要重新組織成一個或多個更明確的ADT，可看書中p137的例子
 #### 一定要理解類別所實作的抽像是什麼
 書中舉例作者開發一個 方格 控制項的界面 但是實際上 他是試算表控制項 因此使用 方格控制項的界面包裹試算表控制項， 而因為作者是想開發方格控制項 因此 暴露出來的 子程式只有跟方個控制項有關， 試算表控制項的子程式都被隱藏起來。
 #### 提供成對的服務
 大多數操作都有何其相應及相等或是相反的操作， 因此在建立類別的公用 子程式時， 要決定是否需要另外一個與之 相補的操作
 #### 把不相關的資訊移到其他類別中
 ####盡可能讓介面可程式化， 而不是表達語義
 可程式化 指的是 界面中的資料類型和其他屬性 構成， 可被編譯器 檢查 錯誤， 而表達語意 指的 這個界面應該要怎麼被使用，例如 RoutineA 必須在 RoutineB 前被呼叫。 因為 表達語意的功能無法被編譯器檢查錯誤， 因此表達 語意 應該 用註解的方式， 讓介面不依賴這些說明
  #### 謹防在修改時破壞介面的抽象
  #### 不要添加與介面抽象不一致的公用成員
  #### 同時考慮抽象性和內聚性
  通常有良好的抽象性時該類別都有良好的 內聚性， 因此當你發現某個類別的內聚性很弱 但又不知道怎麼改時， 可以改問自己這個類別是否表現一致的抽象。
  ### 良好的封裝
  封裝相比於抽象， 封裝是強制阻止你看到細節怎麼實作， 而抽象只是可以讓你 忽略實作。 作者的經驗來說只要沒有封裝，抽象往往很容易被打破， 因此這兩個通常會一起都有
  #### 盡可能的限制類別和成員的 可存取性
  有一個 判斷標準是 採用哪種方式最能保護介面抽象的完整性， 以此去判斷要使用public, protect還是private。
  #### 不要公開暴露成員資料
  #### 避免把私用的實作細節放入類別的介面中
   例如在類別的private屬性中直接使用string新增一個成員，這樣就暴露了成員的實作，書中提到effective c++的做法是新增一個此類別的實作類別，只有此類別能使用該實作類別並使用實作類別取得實作此類別的成員。
   #### 不要對類別的使用者做出任何假設
   類別的設計和實作應該符合類別介面 所隱藏的用意， 不應該假設他會被如何使用或是不會被如何使用， 像是下面的例子
   ```
   -- 請將x, y, z 初始化為1,否則會崩潰。
   ```
   #### 避免使用friend class
   在某些特定環境下 使用 friend class 可以幫助管理複雜度， 但在一般情況下 friend class 會破壞封裝。
   #### 不要因為一個子程式裡僅 使用 公用 子程式 就把他歸入公開介面
   一個子程式只使用公開的子程式就把他公開不是一個重要的考慮因素， 而是該考慮提供介面時有沒有需要公開這個程式
   #### 讓閱讀程式碼比編寫程式碼更方便
   在開發時通常閱讀程式碼的時間會比編寫程式碼時間還要長， 因此可讀性非常重要， 在一個類別中當有一子程式並非完全符合這個類別， 但是可能會讓開發更方便， 我們必須避免這個狀況以免影響可閱讀性。
   #### 要格外警惕從語意上破壞封裝性
   破壞封裝性可以從語義上或者是從語法上， 語法上可以輕易地透過private解決， 而語法上就是完全另外一件事，例如下面有問題的例子:
   * 不去呼叫A類別的Init()，因為你知道在PerformFirstOeration()時就會呼叫過
   * 不在Retrieve(database)前呼叫database.Connect()，因為你知道在裡頭她會去判斷有沒有跟database連線上。
   * 不去呼叫A類別的Terminate()，因為你知道在PerformFinalOeration()時就會呼叫
   上面的問題在於你 呼叫程式碼時 不是依賴於類別的公開介面， 而是依賴於類別的私用實作， 每當你發現自己是透過查看類別內部的 實作 來得知如何使用這個類別時， 你就已經不是在針對介面寫程式了， 而是由經過界面直接針對內部的實作來寫程式， 破壞了封裝性， 一旦破壞了 封裝性 ，抽象能力也就遭殃了
   而當如果你不知道如何使用一個類別的公開介面時， 不是拉出類別的原始碼， 去看裡面的實作， 而是去聯絡作者， 告知他他不知道怎麼使用這個類別， 而你想得到的也不是他真的 怎麼做， 而是由他去修改類別介面， 修改完後再讓你看看你能不能知道如何使用。
   #### 留意過於緊密的耦合關係
   通常兩個類別越是losse coupling越好，以下是建議
   * 盡可能限制著類別和成員的可存取性
   * 避免使用友誼類別， 因為他們是緊密耦合的
   * 在基底類別中把資料宣告為private而非protected， 以正的衍生類別和基底類別之間的耦合程度
   * 避免在類別的公開 界面中 暴露成員資料
   * 對於從語義上破壞封裝性保持警惕
   * （？？？）察覺6-3節講的Demeter法則
   ##  有關設計和實作的議題
   ### 包含（has a ......的關係）
   包含（containment） 表示的是一個類別含有1個基本資料元素和物件
   ####  經由包含來實作has a關系
   例如員工有一個（has a）姓名、 一個電話號碼， 那你可以讓姓名、電話號碼 成為員工 類別的資料成員
   #### 在萬不得已時經由private繼承來實作has a關係
   在某些狀況你發現無法把一個物件當作另外一個物件的成員來實作包含關係， 一些專家建議可以使用private繼承來實作has a， 這麼做的原因是要讓包含那邊能夠存取被包含類別的protected成員， 但這個做法會造成衍生類別與基底類別形成一種過於緊密的關係而破壞封裝性。
   #### 警惕有超過約7個資料成員的類別
   
   ### 繼承是一個is a關係
   繼承的概念是說某一個類別是另外一個類別的特殊化。 其目的在於透過一個基底類別來定義出兩個或多個衍生類別 並提供共有元素
   從決定使用騎乘時你必須要做一下決策
   * 對於每一個成員函數而言他應該對衍生類別可見嗎？ 他應該有預設的實作嗎？ 這個預設的實作能被複寫嗎？
   * 每一個資料成員而言他應該對衍生類別可見嗎
   下面來詳細解釋如何考慮這些事項
   #### 用public 繼承來實作一個is a關係
   使用 繼承 來建立新類別時， 是在表明這個新類別是現有類別的特殊版本， 基底類別會對衍生類別作什麼有所期待， 也做出了限制， 因此如果衍生類別無法完全遵守基底類別定義的介面契約時， 繼承就不是一個正確的實作技術 ，請改用包含的方式
   #### 要使用繼承就要進行詳細說明， 否則不要使用，因為繼承是一個危險、增加複雜度的技術
#### 遵循LISKOV替代原則
liskov總結為 衍生類別必須能透過基底類別的介面而被使用， 且使用者無需了解兩者之間的差異， 否則會因為不同的衍生類別需要去記憶相同名稱的函式卻做不同事情。
#### 確保只繼承需要繼承的部分
衍生類別可以只繼承函式成員的介面和實作也可以介面與實作都繼承。 當你選擇透過繼承的方式實作一個新類別時，請針對每一個子程式仔細考慮你所希望繼承的方式。 如果你只想使用一個類別的實作而不是介面， 那就應該採用包含的方式而不該用繼承。
#### 不要覆寫一個不可覆寫的 成員函式
例如 一個函式在基底類別是private， 折騎乘後不該取一個相同名稱的函式，因為閱讀者會以為你是在覆寫他，但其實只是剛好同名而已。
#### 把共用的介面、資料及操作放在繼承樹中盡可能高的位置
如果你發現一個子程式移到更高的層次後會破壞該層物件的抽象性則該停手了
#### 只有一個實例的類別是值得懷疑的

只需要一個實例 可能代表設計中把物件和類別混為一談， 考慮一下能否指建立一個新物件而非一個新類別， 衍生類別中的差異能否改用資料而非新類別來表達。
#### 只有一個衍生類別的基底類別也值得懷疑

這可能是開發者為了未來的開發而提前設計， 但是最好的方法並非如此， 而是讓眼下的工作成果盡可能清晰簡單 直接了當， 也就是說不要建立任何並非絕對必要的繼承結構

#### 衍生後複寫了某個字程式但是沒有在其中做任何事這也值得懷疑

舉例有一個Cat類別，其中有Scatch()這個成員含式，而有些貓無法抓，所以產生一個繼承Cat類別的衍生類別ScatchLessCat，並且對Scatch()覆寫，讓他不做任何事。這有幾個問題

-   他修改了基底類別的介面所表達的意義， 破壞了基底類別所代表的抽象
-   如果你從這個衍生類別進一步 衍生出其他類別時會迅速失控，例如沒有尾巴的貓，不捉老鼠的貓等等
-   程式碼 會逐漸變得混亂而難以維護， 因為基底類別的介面的行為幾乎無法讓人理解其衍生類別的行為

#### 避免讓繼承體系過深

過深的層次會讓複雜度顯著提高並且提高錯誤率

#### 盡量使用多型避免大量的類型檢查

例如用一個switch case 去判斷要畫圓形還是方形或是其他型，這就改用繼承並去多型Draw()這個函數是比較好的方法。

#### 讓所有資料都是private

### 多重繼承

在使用多種繼承權應考慮其他方案並謹慎的評估他可能會對系統的複雜性和可理解性產生的影響

#### 為什麼會有這麼多關於繼承的規則

前面提出的規則能讓您遠離繼承有關的麻煩， 而繼承往往和你的程式設計師的首要技術與使命背道而馳，下面總結何時使用繼承和包含

-   如果多個類別共享資料而非行為， 而應該是去建立這個類別可以包含的公用物件
-   如果多個類別共享行為而非資料， 應該是讓他們從共同的基底類別繼承來， 並在基底類別定義 公用的子程式
-   如果多個類別既共享資料也共享行為，應該要讓他們從一個共同的基底類別繼承而來並在基底類別定義共用的資料和子程式
-   到你想由基底類別控制你的介面時， 就是用繼承； 當你想自己控制你的界面時就是用包含

### 成員函式和資料成員

#### 讓類別中的子程式數量盡可能的少

#### 用隱含的方式禁止你不需要的成員函式與運算子

將你不想要使用的東西定義為private，禁止呼叫方程式碼去存取

#### 減少類別所呼叫的不同子程式的數量

#### 對於其他類別的子程式的間接呼叫要盡可能地少。

例如account.ContactPerson().FaytimeContractInfo()越少越好

#### 一般來說應盡量減小類別和類別之間相互合作的範圍

盡量要下面這幾個數字減到最小

-   實例化物件的種類數量
-   （？？？）在被實例化物件上直接呼叫的不同的子程式的數量
-   呼叫由其他物件回傳之物件的子城市的數量
### 建構函式
#### 如果可以盡可能在所有 建構函式 中初始化所有資料成員
#### 同一個類別只會有單一實例時，用私用的方式把建構函式隱藏起來
建構函式隱藏起來後 使用一個公開的函式 去取得這個實例
#### 優先採用deep copy, 除非論證可行才使用shallow copy
深層拷貝是指物件複製時是member-wise copy
而淺層拷貝通常都只是指向或是參考某一實例。 淺層拷貝或許能提高效能 但是需要完全確保能提高效能 否則只是提高程式碼的複雜度是沒有益處的
## 建立類別的原因
### 為現實世界中的物件建模
###  為抽象的物件建模
### 降低複雜度
建立一個類別來把資訊隱藏起來就可以無須再去考慮他們
### 隔離複雜度
無論複雜度表現為何種型態 只要發生錯誤還在類別的 局部 而未擴散到整個 程式碼 ，想要找到他就會比較容易， 並且只要介面沒替換就可以換 裡頭的實作
### 隱藏實作細節
###  限制變動的影響範圍 
把容易變動的部分隔離開來，這樣就能把變動所帶來的影響限制在一個或少數幾個類別的範圍內。 把容易變動的部分設計成容易修改
###  隱藏全域資料
如果你需要使用全域資料就可以把它實作的細節隱藏到某個類別的介面背後。 透過 存取 子程式來操控全域資料有許多好處， 你可以監控這些資料的存取 並且使用存取子程式的方式可以促使你去思考有關資料是否就應該是全域的。 通常 全域資料其實只不過是物件資料而已
### 讓參數傳的更順暢
###  建立中心控制點
只用一個地方來控制一項任務是個好主意
### 讓程式碼更易於重用
### 把相關操作包裝到一起
## 應該避免的類別
### 避免建立萬能類別
像是一個類別使用get及set 取向其他類別所取資料 深入到其他類別的工作中並告訴他們該如何做， 那應該思考把這些功能放到其他類別而不是使用萬能類別
###  消除無關緊要的類別
如果一個類別只包含資料但不包含行為 那應該要想想他真的是一個類別嗎， 同時思考要不要把這個類別降級
### 避免用動詞命名的類別
只有行為而沒有資料的類別往往不是一個真正的類別
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjQ2OTg5MDgyLDEyMTMwMDA5NzIsMjAxMD
MzNjgsNjgwMDEzNDU5LDE1NTY0NDYzMjUsMTczMjM3ODk4MSwt
MTM4NzQxMzIwMywtMjA4MTYyNjExLC0xMTIzNTczMjExLC0xOT
k1MjMwNjk4LDEzNDY0ODA3OTMsNTQyNzU4NDQ4LDIwMDEyNjUy
NDIsMTY0MDEwODkzNSwyMTExOTYyMDAyLC0xODAyMDQ1NzcsLT
k5Nzk1MTkxOSw4MDA0OTM4MTgsLTE5ODA3Nzk4MTIsLTY2Mzc1
MjczMF19
-->