# 表格驅動法

表格驅動法是一種設計模式，相對於邏輯述句(if, case等)，他是在表格尋找資訊而不是用邏輯判斷。凡事能透過邏輯述句來選擇的事物皆可使用表格驅動法選擇。
例如文字分類，使用邏輯述句會有大量的判斷，像是要判斷a-z、A-Z、0-9、特殊符號。使用表格驅動法只要先把這些文字預先儲存至表格，在用查表的方式就可達到一樣的功能。

使用表格驅動法要先解決的兩個問題:
1. 怎樣從表格查詢項目
2. 表格內要儲存甚麼資料

## 怎樣從表格查詢項目
當資料數小時沒什麼問題，但是當資料數量龐大時要如何有效的查表，有三種方法可以查表:
* 直接存取
* 索引存取
* 階梯存取

### 直接存取表
如其名，直接查表，替代複雜的邏輯判斷。無須繞複雜的圈子就能找到表格內的資訊，舉個例子:
```C++
int DayPerMonth = {31,28,31,30}
days = DayPerMonth[month-1];
```
書中提到一個例子，有一個氣象站會紀錄天氣資訊，每個資訊都有多個欄位。假如說這些欄位有26種資料型態，現在想要讓他們印出來，使用邏輯基礎法的話會式下面這樣:
```
如果還有資料要印 則:
	處理Header
	解析資料
	if 資料是A型態
		用A型態印出
	else 如果資料是B型態
		用B型態印出
		⋮
	else 如果資料是Z型態
		用Z型態印出
```

而透過表格驅動法的話會是

```
enum DataType {
	A,
	B,
	⋮
	Z
};

如果還有資料要印 則:
	處理Header
	解析資料
	根據資料類型查表
	用查表查到的資料類型印出資料
```
在`根據資料類型查表`這步驟，直覺的方式是使用向是C++中的case，更好的方式是建立一個Abstract Class，並且個資料型態繼承它並自訂行為。建立好後透過下列方式建立物件，在這個物件中儲存指標指向各類物件。
```C++
Abstract* field[dataTypeCount];
field[A] = new AField();
field[B] = new BField();
⋮
field[Z] = new ZField();


```

### 



## 表格內要儲存甚麼資料
儲存普通資料時沒問題，但如果查表要的結果是一些動作，則需要儲存一段程式碼，又或是指向該動作的函式指標。以上兩種皆會使表格內容變複雜。

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQxNzU0MTE4NSwxMzYwMTk0NjYyLDQ1Nz
g4NTEzOCwxNDIyOTcwMDMwLC04MjEzMzAwNjUsLTExNTM0MTYz
NjZdfQ==
-->