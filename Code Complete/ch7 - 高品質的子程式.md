# 高品質的子程式
##  建立子程式的正當理由
#### 降低複雜度
建立子程式可以將程式分割為多個小部分 可以降低理解的困難度並且抽象化， 如果程式有多個巢狀迴圈應該考慮建立個別的子程式
#### 引入易懂的抽象
####  避免程式碼 重複
#### 幫助子類別的設計
對一個簡短而工整的子程式需要進行複寫時會比覆寫冗長而邋遢的子程式更容易並且犯錯的機率更小
#### 隱藏 順序
#### 隱藏指標操作
#### 提高可移植性
#### 簡化複雜的布林判斷
#### 改善效能
####  子程式不一定要很短
### 似乎過於簡單而沒必要寫成子程式的操作
通常會糾結在為一些簡單 的判斷 將他寫成字程式 這個問題的最佳解法通常都是真的把他寫成子程式 尤其是那些經常會使用的簡單計算， 並且對提高程式的可讀性有很大的效果
## 在子程式上的設計
我們的目標是把你的子程式只完成一件事
 也就是說要 讓子程式 有高內聚力，最好能達到功能內聚力，讓子程式只專心做一件事
 不過下面幾項是不太好的內聚力
 -  順序內聚力
  指的是一個子程式內在執行時會用到先前的的結果當作Input，要改善這個狀態可以將相依的子程式碼拆成其他子程式，讓這個子程式去呼叫他們。
  - 通訊內聚力
  指的是在一個子程式內對相同的資料做不同處理， 解決的方法是將它們拆成不同的子程式
  - 暫時的內聚力
  指的是因為一些因素需要一起執行才放在一起的子程式，像是startup()，他會去執行一堆只有這時候才會聚集在一起的子程式，此時應該要讓他呼叫其他子程式去完成任務而非自己實作。
  除了這上面的內聚力以外其他的內聚力都是不可取的 他會導致程式碼混亂並且難以修改
  下面指的是不好的內聚力
  -  程式內聚力
  指的是 一組會依照固定順序執行程式放在同一個模組中 例如1個函式檢查檔案的權限然後開啟檔案， 解決方法是把他們的功能畫成不同的子程式然後個別呼叫
  - 邏輯內聚力
 例如一個名為輸入全部資料的程式 包含了輸入客戶姓名以及員工出行資訊等等不太相關的程式時 就被稱為邏輯內聚力 這個問題的解法 應該要使用不同的子程式去完成這些任務
 - 巧合的內聚力
 指的是一個子程式內有多個不相關的功能
上述不好的內聚力應該要改寫成由更好的內聚力組成
##  好的程式名稱
#### 描述此程式所做的所有事情
如果你所做的事情會讓子程式的名稱非常冗長， 那應該要換一種寫程式的方式以不產生副作用的方式來解決問題
#### 避免使用無意義 模糊或表述不清 的動詞
#### 根據需要，確定子程式的名稱的長度
變數通常最佳長度是9到15個字， 子程式的通常比變數更複雜， 而在類別的子程式有類別名稱提供了一部分的名稱， 所以子程式的長度可長可短一切都看需求。
#### 給程序命名時使用語氣強烈的動詞加受詞的形式
PrintDocument等等
#### 準確使用反義詞
get/set, add/del等等
#### 為常用操作卻麗命名規則
employee.id()
qqq.getid()
aaa()
ggg.id.get()
這些都是取得id的方法，應要以統一的方式實作
##  子程式可以寫多長
長度及錯誤率其實不一定相關， 有看你子程式的內聚力、巢狀深度、變數的數量或是決策點的數量等等因素來決定比較好，也就是說根據複雜度來決定子程式的長度。 不過子程式盡量不要超過200行， 超過200行後就會影響可讀性
## 如何使用子程式參數
### 按照輸入修改輸出的順序來排列參數
### 如果幾個子程式都使用了類似的參數，那就讓他們這些參數排列順序保持一致
###  使用所有參數
沒使用到的參數就刪除
### 把指出狀態和錯誤的變數擺在最後
他們都是輸出所以擺最後
### 不要把子程式的參數當作工作用的變數
如果要使用參數， 則應該要用另外一個變數來複製一份，然後 用新的變數來操作，在c++中能在參數使用const reference來避免修改
### 在介面中對參數的假定加以說明
使用註解把參數說明清楚
### 把子程式的參數限制在大約7個以內
如果你發現自己一直需要 傳遞 很多參數， 這代表 子程式之間的耦合太過緊密，應該要重新設計這些子程式降低耦合度
如果你經常將相同的資料傳給多個子程式， 那應該要將這些子程式編成一個類別， 並將這些資料轉為類別內部的資料
### 考慮對參數採用表示輸入修改輸出的命名規則
### 為子程式傳遞用以維持其介面抽象的變數和物件
當一個物件要將其資料傳遞給子程式時， 到底要將整個物件傳遞過去還是只傳遞有需要的部分， 這個問題的關鍵應該要思考說子程式的介面要表達哪種抽象。 如果要表達的抽像是子程式期望的三項特定資料， 只不過這三項資料都恰巧由同一個物件提供， 那就應該只單獨傳遞這三項資料。 如果子程式的介面要表達的抽像是一直擁有某個特定物件， 那就應該要傳遞整個物件
## macro及inline子程式
#### 把macro運算包在小括號內
#### 把含有多條述句的macro用大括號刮起來
不過多條述句不是良好使用macro的方法要盡量少用
#### 如果Macro展開後如同子程式，那就應該要為他以子程式命名的方法命名
這樣能夠在為來將macro替換成子程式
### inline
#### 節制地使用inline
inline暴露了實作的細節給使用inline的函式

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk1NzczNTU1OSwtMTI1OTE1NTg3NSwtMj
Q4NzY3MjcsMzA3OTY5MDQ1LC0xODk3MTU1ODI2LC05NDgyOTc0
NjksLTE1MjA1MzEyMzEsMTg5Nzc5NzA4NiwtMjA4MTQ2MDQ3Mi
wxOTI4MDk0OTA1LC0xODk2OTY0MDI5LC0xMjkyMzUxOTgzLC05
Nzk3NDc5NDYsNDAyMjExOTAsLTEzMzM5MDg2MTIsLTQ4OTQ4Mj
I2NSwtNjIyMzM3NzAyLC0xOTEwMTcxNzQyLC0yMDg4NzQ2NjEy
XX0=
-->