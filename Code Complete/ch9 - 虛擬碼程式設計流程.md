# 虛擬碼程式設計流程
### 類別建立
```
\                ---------------------------
				|							|
				v							|
開始---->建立類別的整體設計------------>建立類別中的子程式
				^							^
				|							|
				└----->複審並測試整個類別 <----┘ 
							└--------------------->完成
```	

### 子程式建立
```
開始------->設計子程式<----------->檢查設計
			   ^				   |
			   |				   |
			   |                   v
		複審並測試程式碼 <---> 編寫子程式的程式碼  
				└--------------------------------->完成
```	
## 如何寫好pseudocode
* 避免使用目標程式語言的語法，虛擬碼可以讓你在一個目標語言略高的層次進行設計。
* 不要管目標語言，以虛擬碼描述解決方法的原意
* 虛擬碼要在足夠低的層次上撰寫，以便由他來近乎自動地產生程式碼。如果不夠低，會有些問題細節被忽略。
* 必須要不斷精煉，直到看起來很容易能寫出程式碼為止
## 透過PPP建立子程式
### 設計子程式
* 檢查先決條件，檢查該子程式是否以定義好要做的工作並且是否與整體設計匹配
	* 也要檢查進入及離開子程式時的需求是否達成(資料位於合法範圍、檔案已打開/關閉、緩衝區填滿/清空)
* 定義子程式要解決的問題
* 為子程式命名
* 決定如何測試你的子程式
* 使用standard library
* 考慮錯誤處理
* 考慮效率問題
	* 不是說每個程式都要有很高的效率，是說你要為了未來能夠將程式碼提高效率而設計，像是要有良好的抽象及封裝，未來可以換成其他效率更高的演算法。
	* 通常要改善效率應該先著重在高層次的設計，除非你能證明子程式無法滿足效率標準，不然去改善只是浪費力氣。
* 研究演算法及資料類型
* 編寫虛擬碼
做完上述需求就可以開始寫虛擬碼了
* 考慮資料
	* 如果資料的操作是該子程式的重點，則值得在考慮子程式的邏輯前先搞清楚資料，把資料定義好。
* 檢查虛擬碼
	* 想想你如何向別人解釋虛擬碼
* 在虛擬碼中試驗想法，並且留下最好的結果(迭代)
	* 反覆的修改虛擬碼描述的子程式，找到幾乎能直接從虛擬碼轉換成程式碼的版本，如果層次太高就分解他，持續精煉，直到你覺得不寫程式碼是在浪費時間為止。
### 編寫子程式的程式碼
* 寫宣告
* 將虛擬碼轉成註解
* 為每條註解寫程式
* 檢查程式是否需要分解
	* 如果程式太大，則重構成另外一個子程式，並且也使用ppp設計
	* 如果沒有要拆，可以在為那些有點數量的程式編寫虛擬碼。
* 檢查程式碼
	* 如果不知道為什麼需要這段程式碼的話就想辦法去理解，做實驗或是跟別人討論等等
* 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5ODY0MjA4ODMsNjI4OTM2MjcxLC0xNj
IyNzU0ODY2LDg4MTcyMjY0MCwtMTExOTkwODE5LDYwMzA0NzQ1
NV19
-->