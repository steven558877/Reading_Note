# 開發者測試
* Unit test: 一個類別、子程式、小程式
* Component test: 相比於上條，規模可能是較大的類別、套件、程式
* Integration test: 兩個或更多類別、套件、元件，最好在開發時有兩個以上的類別時就開始做，並做到系統開發完成
* Regression test: 重複執行先前跑過的測試，找出沒找到的問題
* System test: 最終設定下(軟硬體)去測試整個軟體，包含測試安全性、效能、資源消耗、時序等無法在低層次測試體現的問題。
## 開發者測試的推薦方法
系統化的開發方法可以提高發現錯誤的能力及讓花費最少，要做到以下幾點:
* 對每一項需求進行測試，以確保需求都已經被實作。在需求階段就計畫好測試案例，或是早點開始，最好在開始寫待測單元前。
* 注意對需求裡面常見的疏漏進行測試
* 安全級別、資料儲存、安裝過程及系統可靠性都是好的測試素材。
* 對每一個相關的設計關注點進行測試，確保設計已被實現，並在計畫時就設計好測試案例。
* 用基礎測試來擴充對需求和設計的詳細測試案例
* 增加資料流測試(章節後面詳述)。
* 至少應該要測試到每一行程式碼
* 用核對表紀錄本專案所發生的錯誤，及過去專案中發生錯誤的類型。

## 測試先行還是測試後行
從書中引用的圖中顯示，愈早發現錯誤所需要付出的成本愈低，這是應該要測試先行的原因之一
* 先寫及後寫測試只差再順序，並不會多多少effort
* 先寫測試可以提早發現錯誤
* 先寫測試可以強迫你思考需求及設計，這會催生更高品質的程式碼
* 先寫測試可以提早暴露需求的問題，糟糕的需求很難寫出測試
## 開發者測試的侷限性
* 開發者傾向「乾淨測試」
	* 指的是檢查程式法會正常運作的測試，正確的測試中正常以及錯誤的比例會是1:5。
* 程式設計師會對coverage過度樂觀

## 測試技巧錦囊
* 對所有可能發生的狀況去做測試是不可行的，例如一個5個字元的字串，可能的結果單純以英文文字來看就有26^5種，全測是不切實際的。
* 專注在於尋找會讓測試結果不同的案例，而非找一堆相同結果的，下面會說如何找到這種案例。
### 結構化的基礎測試
* 核心概念是對程式中的每條述句至少測試一次。
* 如果是if/while述句，測試可以完全測試所有狀況，簡單的方法是算一算這段程式有多少條狀況，列出來後去測試每條狀況，據此產生出最少數量的測試案例。
* 計算測試案例數量的方法
	* 從第一行開始，計算數量，從1開始。
	* 遇到邏輯述句，像是if/while/for/and/or等等，數量加1
	* 遇到每個case時數量加1，case沒有default時再加1
* 例如下面的程式:
```C++
Statment1; // 從1開始, count: 1
Statment2; // count: 1
if (x < 0) // count: 2
{
	Statment3; // count: 2
}
```
* 遇到if時count要加1的原因是你需要兩段程式去測試這兩種狀況:
	* x < 0
	* x >= 0
* 所以在這段程式最少數量的測試案例就是2個
* 如果程式擴大，裏頭的邏輯述句變多時，測試案例會急遽增加，因此應保持子程式或邏輯述句簡短以便測試。
* 這種測試能確保所有程式碼皆可被執行，但是他不能說明資料變化的情況。
### 資料流測試
* 資料的狀態有以下幾種:
	* 已定義
	* 已使用
	* 已銷毀
* 控制流的狀態:
	* 已進入:控制流已進入某個子程式
	* 已結束 控制流離開子程式
* 好的開發測試案例的方法流程是:
	* 首先，先完成結構化的基礎測試，即使沒有測試所以已定義-已使用的資料流也沒關係
	* 補上所有已定義-已使用的資料流
	* 如下程式，第一步先建立x<0,y<0為真及x<0,y<0為假的測試案例
	* 第二步，建立x<0為真,y<0為假及x<0為假,y<0為真的測試案例，以上兩點為結構化的測試案例開發
	*再來補上已定義-已使用的資料流的測試案例，目前測試對z來說沒有測試到，要測試已定義-已使用的案例，有幾種case
		* 第3行定義，第8行第一次使用，前面測試沒有附蓋到
		* 第3行定義，第16行第一次使用，前面測試沒有附蓋到
		* 第12行定義，第16行第一次使用，前面測試沒有附蓋到
 ```C++
int x = 0;
int y = 0;
int z = 0;
void foo(int) {};

if (x < 0)
{
	foo(z);
}
else
{
	z = 2;
}

if (y < 0)
{
	foo(z);
}
else
{
	Statment2;
}
```

### 猜測錯誤
作為正式測試的補充，是以猜測程式的哪個部分會發生錯誤的基礎上去建立測項，猜測錯誤的來源可能來自經驗、過往發生錯誤的列表。如果有這種列表存在，就能提高猜測的命中率，下面將說特定的錯誤類型
### 邊界值分析
**off-by-one**是最經典的錯誤。對邊界值測試的方法是建立三種測項，剛好大於邊界值、剛好小於邊界值及剛好等於邊界值。
### 幾種壞的測試資料(錯誤的input)
可以猜測有下面幾種壞的資料
* 資料太少
* 資料太多
* 錯誤的資料
* 長度錯誤的資料
* 未初始化的資料
### 好的測試資料
正常的資料也可能暗藏錯誤，可以測試的方法
* 正常的情況，一般的預期值
* 正常狀況的最小值
* 正常狀況的最大值
### 採用容易人工檢查的測試案例
例如計算20000\*3的人工計算難度會比835490\*3小很多，難度愈低，人工發生錯誤的機率就愈低。

## 典型錯誤
越了解錯誤你就越能做得更好
### 哪些類別包含最多錯誤
* 錯誤並非平均分散在每個類別中，有少數類別存在著最多錯誤。	
* 少數子程式中存在最多錯誤，並且這些子程式去修復的代價有可能會超過開發系統的成本
* 如果能省掉修復那些子程式的化就能夠大幅減少成本
* 如何確定容易出問題的子程式是一個關鍵因素。
### 錯誤分類
書中給出一些錯誤類型以及他們發生率的百分比，但是這些百分比在不同研究中呈現不同數字，但有以下幾點總結:
* 大多數錯誤的影響範圍相當集中
* 許多錯誤發生在建構的範疇之外:
	* 指的是開發以外的因素，像是缺乏domain knowledge、頻繁變動及矛盾的需求、溝通失效等等
* 大多數建構時期的錯誤是程式設計師的失誤
* 筆誤是一個常見的錯誤來源
* 錯誤發生的原因有一部分是因為程式設計師對設計理解錯誤
* 大多數錯誤是容易修正的
	* 85%可以在幾小時修正，15%可以在幾天內修正，只有少部分需要花極長時間
* 總結身處的組織中對錯誤處理的經驗
	* 雖然有時很難有結論，但是評估開發方法是一個好的開始
### 不完善的建構過程引發的錯誤所佔的比例
* 在小型專案中，寫code發生的錯誤是75%，10%源自需求，15%源自設計
* 在大型專案中，寫code發生的錯誤會降低，但是至少也有35%
### 你期望能發現多少錯誤
* 1000行程式碼平均會發生1-25個錯誤
* 透過「程式碼詳查」技術讓微軟大幅降低程式碼錯誤
	* 程式碼詳查: 每個人分配一些程式碼，先看過後開會討論問題點。
* 統計數據說開發高品質的軟體比開發低品質的軟體，然後再去修正的成本低上許多

### 測試本身的錯誤
測試案例本身的錯誤比例不比程式碼本身少，因此會發生測試結果錯誤卻找了老半天才發現是測試案例的錯誤，可以透過以下方法減少測試案例的錯誤量:
* 檢查你的工作
	* 像對待production code那樣對待 test code，逐行檢查、double check 等等
* 開發軟體時就要計劃好測試案例
* 保留測試案例
* 將單元測試納入測試框架
	* 每完成一次單元測試就將它整合到系統極的測試框架中，減少丟棄的測試案例
### 測試支援工具
* 不特別指出特定工具，自己找
#### 為測試各個類別建造鷹架
* 建造鷹架可以更方便的測試程式碼，常見的鷹架方法有:
	* 立刻返回控制權，不做任何動作
	* 檢查傳給他的資料
	* 輸出診斷資訊
	* 返回使用者互動輸入的值
	* 不管任何輸入都返回標準回應
	* 消耗真實物件/子程式的時鐘週期
	* 以慢速/擁腫/簡單/粗略的方式實現真實物件/子程式的功能
* 另一種鷹架類型是呼叫待測試的真實函數的偽造函數，稱為驅動函數/測試裝具:
	* 用固定一組輸入呼叫物件
	* 提示使用者輸入，然後根據輸入去呼叫物件
	* 從檔案讀入參數，並據此呼叫物件
	* 用一組預先定義的輸入資料去多次呼叫相關的物件。
* 最後一種稱作dummy file
	* 真實檔案的縮小版
	* 可以為了測試而特別製作內容，讓各種錯誤被暴露出來
### Diff 工具
測試輸出是否如預期的方法之一是先產生預期輸出到一個檔案，再將實際輸出輸出至另一個檔案，並用diff工具去比較他們的不同。
### 測試資料產生器
* 正確的設計隨機資料產生器可以產生意想不到、不尋常的測試資料
* 隨機資料產生器能做的比人工產生資料更徹底
* 你可以強化隨機資料產生器的真實性，集中測試使用者最可能會用到的範圍
### 系統干擾器
* 記憶體填充
	* 開始執行前將任意數值填充進記憶體，變數就不會剛好是0而測試不到沒有初始化的案例
* 記憶體抖動
	* 在多工系統，有些工具能夠重新組織記憶體，能夠確保程式碼都只依賴存放在相對位置的資料，而非絕對位置
* 選擇性記憶體失敗
	* 模擬記憶體不足的狀況，在測試動態分配記憶體的程式很有用
* 記憶體存取檢查(邊界檢查)
	* 邊界檢查監視各種指標操作，確保所有指標運作正常，在尋找未初始化或者懸空的指標很有用
## 改善測試程序

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTcyOTY5MTY0NSwyNTI3OTQ1NTIsMjA5Mz
cwMTExLDE5MTA3MzUwNzcsLTE0MzUzNzQxNzQsMTM0NjIxNTM3
MSwxNzMxMTk5NTMzLDE1ODI0NjkyNjAsMzc1NDg1NzAwLC0zOD
EzNDY3NjYsLTgzMjQzMDQ0OSwtMzA0NTk4ODA5LC0xMzQ3MjY5
MTAzLDE0NDc4MDQ5ODAsMTM0NzM5NTg4OCwtNDM1NDExOTg0LC
0xOTY3OTI0ODcyLDIwOTMwNjk5MzMsMTE3MTI1MDcwNSw4ODYz
NTY1NzBdfQ==
-->