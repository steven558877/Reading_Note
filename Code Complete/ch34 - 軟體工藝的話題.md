# 軟體工藝的話題
## 征服複雜度
* 將架構層面的東西畫分成多個子系統，讓思緒可以專注在較小的部分
* 定義好類別介面，就可以不用知道實作細節
* 避免使用深層次的繼承，會消耗許多腦力
* 深層的巢狀迴圈都可以轉變為簡單的控制結構
* 仔細定義類別抽象介面，進而不需要記住細節
* 仔細定義如何做錯誤處理，別濫用不同的方法
* 以系統的觀點對待內建的例外機制，後者會成為非線性的控制結構(???)。例外如果不受約束的使用，會跟 goto 一樣難以理解
* 傳遞給子程式的參數盡量少，已能表達子程式介面抽像的角度去想
* 用規範及約定來分攤大腦的記憶
* 以功能命名變數，說明問題是什麼，而非怎樣實作，能提升抽象層次
* 
## 首先為人寫程式，其次才是機器
* 程式碼必須是要有高可讀性的，不管何時、大專案或小專案。要養成習慣，平常習慣怎麼樣，在實際上工的時候就會是怎樣。
* 定義好變數名稱、子程式名稱、程式碼的布局、簡短的子程式、將複雜邏輯的結果用 bool 儲存並命好名等等。
## 用程式創造環境，而非遷就她
* 如果程式語言沒有某種功能，就自己刻一個出來
* 別因為程式語言提供了某個功能就想使用他，可能是危險的，像是全域變數及goto 等等
## 借助規範集中注意力
* 借助規範避免發生粗心錯誤，例如刪除指標時將其指向 NULL
* 對底層工作增加規範可以提高可預見性，對記憶體請求、錯誤、輸入/輸出和類別介面有規範的處裡，能夠為程式碼加入有意義的結構
## 根據問題領域的術語做程式設計
* 在不同層次的抽象層用不同的用語
* 從上層到下層可能會是: 高層問題領域術語 -> 低層問題領域術語 -> 低層實作結構 -> 程式語言結構和工具 -> 作業系統的操作和機器指令
* 程式語言結構和工具: 程式語言的基礎語法、如果只在這層工作會很痛苦，要處理的細節多到累死
* 低層實作結構: 像是 heap、stack、link list、排序/搜尋演算法，在這層工作仍要處理許多細節問題
* 低層問題領域術語: 介於上層及下層的黏接層，會有基本的問題領域詞彙，但是太基本以至於沒辦法直接使用
* 高層問題領域術語: 提供對問題的抽象能力，並使用問題領域的術語，他不依賴語言的特性，而是依賴於在低層問題領域術語那層建立的介面。
## 注意落石
* 程式設計不為完全的科學及藝術，而是介於中間，且需要大量的個人判斷，因此需要自己注意許多可能會發生的錯誤
* 如果程式碼暗藏玄機，代表他寫得不好
* 少數錯誤的類別要多注意，修正之後可能還會錯，考慮重寫他
* 有些書中的說法不一定是不好，但是值得花心思注意，像是類別的成員多過七個、子程式有超過十個判斷點、三層以上的迴圈、過多變數、與其他類別過於緊密耦合等等。
* 編譯器的警告訊息永遠值得拿來質疑程式碼品質
* 當很難單獨使用某個類別、或是很難測試，可能代表他與其他類別的耦合過於緊密

## 分離軟體及信仰
### 折衷主義
* 公平的對待新技術及舊技術，選擇最好的工具使用
### 實驗
* 軟體開發中許多頑固的方法都是對錯誤的畏懼心理，試圖沒有錯誤是最大的錯誤。
* 用實驗去驗證方法可行
* 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5MzUyMTU0MTEsLTExMDg2OTE2NTUsMT
MwMDY0NjM1NSw0MjUxODYzMzEsLTEzNDY4Mjc2MjIsNjQyOTgw
NzQzLC01MDU5NDIyNTIsMTU4MTIxOTU3MV19
-->